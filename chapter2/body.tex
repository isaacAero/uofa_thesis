
\chapter{Software Implementation: \textit{CellColonySimulator}}


\begin{figure}[!htb]
    \centering


    \begin{tikzpicture}[every text node part/.style={align=center}, 
                    node distance=2cm]


    \begin{scope}[scale=0.85,transform shape]
    \node (start) [startstop] {\codeword{Master.m}};
    \node (in1) [io, below of=start] { Model parameters: $\lambda_1, ... , \lambda_7$ \\
                                       Numerical parameters: $h$, $\Delta t$ \\
                                       Run parameters: \codeword{ensembleSize}, \codeword{sampleTimes}};
    \node (pro1) [process, below of=in1] {\codeword{runSimulation.m}};
    \node (pro2) [process, below of=pro1] {\codeword{ellipse.m}};
    \node (pro3) [process, below of=pro2] {\codeword{updateFood.m}};
    \node (dec1) [decision, below of=pro3, yshift=-1.5cm] {Mitosis Condition};
    \node (pro4) [process, below of=dec1, yshift=-1.5cm] {\codeword{addCell.m}};
    \node (proNothing) [process, left of=pro4, xshift=-1.5cm] {Proceed};
    \node (pro5) [process, below of=pro4] {\codeword{updateNodes.m}};
    %\node (pro5) [process, right of=dec1, xshift=2cm] {Process 2b};
    \node (out1) [io, below of=pro5] {Run Statistics at \codeword{sampleTimes}: \\
                                      \codeword{compactness},
                                      \codeword{averageRadius},
                                      \codeword{cellCount},
                                      $\bar{\mu}$};
    \node (stop) [startstop, below of=out1] {Plot ensemble averaged results};
    \node (for) [process, left of=pro3, xshift=-3.5cm] {Loop over ensemble};
    \node (forTime) [process, right of=pro3,  xshift=3.0cm] {Loop over time};

    \draw [arrow] (start) -- (in1);
    \draw [arrow] (in1) -- (pro1);
    \draw [arrow] (pro1) -- (pro2);
    \draw [arrow] (pro2) -- (pro3);
    \draw [arrow] (pro3) -- (dec1);
    \draw [arrow] (dec1) -| node[anchor=south]{else} (proNothing);
    \draw [arrow] (proNothing) |- node[anchor=south]{} (pro5);
    \draw [arrow] (dec1) -- node[anchor=east]{if}(pro4);
    \draw [arrow] (pro4) -- (pro5);
    \draw [arrow] (pro5) -- (out1);
    \draw [arrow] (out1) -- (stop);
    \draw [arrow] (in1) -| node[anchor=south]{} (for);
    \draw [arrow] (for)  |- node[anchor=south]{} (out1);
    \draw [arrow] (pro1)  -| node[anchor=south]{} (forTime);
    \draw [arrow] (forTime)  |- node[anchor=south]{} (pro5);
    
    %\draw [arrow] (pro2a) -- (out1);
    %\draw [arrow] (out1) -- (stop);

    \end{scope}
\end{tikzpicture}
\caption{A flow chart of \textbf{CellColonySimulator} software package in MATLAB. }
\label{fig:softwareFlowChart}
\end{figure}

\section{The structure of the program}
The program \textbf{CellColonySimulator} is implemented \textit{in-house} with MATLAB as shown in 
figure \ref{fig:softwareFlowChart}. \textbf{CellColonySimulator} is broken up 
into six seperate scripts as per the programming principle of modularity. These include:
\codeword{Master.m},
\codeword{runSimulation.m},
\codeword{ellipse.m},
\codeword{updateFood.m},
\codeword{addCell.m},
\codeword{updateNodes.m}.

\subsection{Calling the update loop in \textit{runSimulation.m}}
The function \codeword{runSimulation.m} takes in the model parameter vector,
$\lambda$, the struct of numerical discretisation parameters, \codeword{numericPack},
the times at which statistics are sampled, \codeword{sampleTimes}, 
the colony data including node positions $(x,y)$ and the network adjacency
matrix, \codeword{connectivity}, and the initial nutrient field 
given by \codeword{food}.
\\

The mesh grid matrices $X$ and $Y$ are taken from \codeword{numericPack} and 
converted to graphics processing unit (GPU) arrays using MATLAB's \codeword{gpuArray()}. This is crucial 
for speed as GPU operations on large matrices are highly optimised and parallelised within 
the GPU architecture. Besides generating descriptive file names for the output plots
and other miscellaneous tasks, \codeword{runSimulation.m} then progresses into 
the primary \codeword{for} loop over the time indices, \codeword{timeIndex}.
\\

A task to print to the console to let the user know what ensemble instance
and \codeword{timeIndex} the program is up to, is done first.
Secondly, based on the current node positions $(x_i,y_i)$ for
$i \in \{1, ..., N_{\textrm{nodes}}\}$, and the number
of edges present in the \codeword{connectivity} matrix, the current number of cells
$N_{\textrm{cells}}$ is counted up
and vectors are associated to the variables $x_{c,k}$,$y_{c,k}$,
$\theta_k$, $p_k$ and $q_k$ (based on equations
 \ref{eqn:semiMajorAxis}, \ref{eqn:semiMinorAxis},
\ref{eqn:orientationAngle} and \ref{eqn:centerPos}) where $k \in \{1, ..., N_{\textrm{cells}}\}$.
These vectors are passed to the function \codeword{ellipse()} (explained in 
subsection \ref{ssec:ellipse})
which computes the colony-level signed distance field (SDF),
which is comprised of the elliptical SDF of each cell indexed $k$.
\\

At this stage the biomass field, \codeword{biomass}, is computed 
from the colony level SDF, based on equation \ref{eqn:biomass}.
The current value of the nutrient field and the biomass field,
are passed to \codeword{updateFood()} (explained in 
subsection \ref{ssec:updateFood}) which updates the nutrient field
based on the Crank-Nicholson method applied to equation \ref{eqn:EOMs_PDE}.
The food at the next time step is outputted from \codeword{updateFood()}.


\subsection{Vectorised computation of colony SDF in \textit{ellipse.m}}\label{ssec:ellipse}


\subsection{A fast Crank-Nicolson scheme in \textit{updateFood.m}}\label{ssec:updateFood}







